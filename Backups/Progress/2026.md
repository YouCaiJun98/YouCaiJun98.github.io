# 2026 Working Progress  
## By 2026/1/7  
* 继续调基于本地LLM的MCP Client（Flag回收）  
    * 优化**推理效率**方面的尝试
        * 摸了下`vllm`框架，期望通过该框架优化推理开销（**降低推理延时+降低显存开销**），但是没有成功：
            * `vllm`框架目前对`VLA`的支持不是很好，参考[vllm官方vla示例](https://github.com/vllm-project/vllm/blob/main/examples/offline_inference/vision_language.py)把`RoboBrain2.0`缝进去；官方示例使用的对话模板是qwen2.5-vl的，需要替换为[修改后含工具调用的jinja模板](https://github.com/YouCaiJun98/mcp-client/blob/main/template/template.jinja)。
            * `vllm`主要面向的是**高并发场景下的大模型推理服务**，它的主要目的是在生产环境中同时服务多个用户，主要的技术贡献在于**显存管理**，用`PageAttention`等技术减少碎片化显存（在这一意义上，它是设计来替代`Pytorch`显存管理方案的）；尽管vllm支持部署量化后的LLM，留有相关的量化接口，但是它并没有集成量化模块，用户须在其他框架下进行模型量化，再将模型迁移到`vllm`中。自己量化`RoboBrain2.0`不太可行，因为需要利用该模型的训练数据做量化参数校正，已在`RoboBrain2.0`官方repo提了[issue](https://github.com/FlagOpen/RoboBrain2.0/issues/31)，希望开放量化后的模型，暂无回复。
                * 1/6 update: 在HF上发现了`RoboBrain2.0`的量化版本，分别是[RoboBrain2.0-7B-W8A16](https://huggingface.co/BAAI/RoboBrain2.0-7B-W8A16)与[RoboBrain2.0-7B-FP8](https://huggingface.co/BAAI/RoboBrain2.0-7B-FP8)。
            * 综上，`vllm`的设计初衷不是单模型推理优化/加速，没能实现利用`vllm`优化推理。
        * 利用上述`RoboBrain2.0`官方提供的量化后checkpoint做测试：
            * 使用[RoboBrain2.0-7B-W8A16](https://huggingface.co/BAAI/RoboBrain2.0-7B-W8A16)版本，模型加载后显存占用由16GB+变化至\~10GB，**推理速度明显降低**，由\~10s变为\~1min，且推理时显存增量明显（增量由\~300M变为\~3000M），推理质量未见退化；
            * 使用[RoboBrain2.0-7B-FP8](https://huggingface.co/BAAI/RoboBrain2.0-7B-FP8)版本，模型加载后显存占用由16GB+变化至\~10GB，推理速度也有明显下降，由 \~10s变为\~20s，但显存无明显增长；
            * 原因似乎是，`transformer`的默认pipeline会把W8反量化回W16，造成额外推理时间和显存开销；量化后模型应搭配特定的优化核使用。
    * **技术路线备份**方面的尝试
        * 评估了不同服务框架下LLM / VLM调用工具(tools)的方法，结论是**对话模板均需手动编写、消息填装与回复解析均需手动实现、多轮交互与工具调用均需手动编排**：
            * 参考`vllm`提供的[官方示例chat_with_tools](https://github.com/vllm-project/vllm/blob/main/examples/offline_inference/chat_with_tools.py)，该框架下LLM调用工具的局限有：
                1. 工具的声明和调用方法**没有按照MCP标准**，需要手工进行message填装和工具声明；
                2. `vllm`的LLM chat pipeline对应的对话模板**完全依赖于对应LLM官方提供的模板，无通用模板**。遇到`RoboBrain2.0`这样的样例，仍需要手工编写含有工具调用的对话模板；
                3. `vllm`中LLM chat pipeline**不含流控制**，在多轮工具调用的场景下，依赖对话模板汇总对话上下文历史 + 手工编写规则判断工具调用循环是否结束。
            * 通过`openai api`实现与本地端口serve的LLM（通过`vllm`实现）进行对话，发现该方案也符合上述结论描述（需要自定义模板、交互前后处理需要手工写、无任务/工具调用编排）。
            * 尝试通过`ollama`启动本地LLM服务，它的产品定位类似于`huggingface`（但仅支持`ollama`官方提供的部分LLM）的model hub + （无模型/推理优化）vllm。发现`ollama`对本地自定义LLM的支持比较差，没找到现成的例子（似乎可以serve `GGUF`格式的[HF模型](https://huggingface.co/Mungert/RoboBrain2.0-7B-GGUF)），轻量化的设计让它更适合新手快速上手，似乎不太适合基于此进行拓展开发。
        * 对于多轮交互与工具调用的编排，或许可以尝试`LangChain`&`LangGraph`。
* 尝试将本地Robobrain2.0 MCP client接入`ros-mcp-server`
    * 

## By 2026/1/21  
* 尝试使用`OpenManus`  
    * `OpenManus`是啥：
        * `Manus`的开源替代，定位是LLM-Agent框架，功能特点有：
            * 具备`Multi-Agent`分工合作能力，可类比`AutoGen`（[官方示例脚本](https://github.com/FoundationAgents/OpenManus/blob/main/run_flow.py)被标记为“unstable”且长达8月未维护）；
            * 可以拆解复杂任务目标、调用真实工具、并在任务失败后重新多次尝试；（可以讲讲搜索的例子）
            * 给了多个真实工具（如浏览器搜索、沙盒程序运行）的调用方法；  
        * 优点：
            * 现成的LLM Agent调用工具（浏览器搜索）示例，可以参考工具接口写法 + 编排控制；
            * 开源（与其他开源多智能体框架相比，暂未看到明显优势）
        * 缺点：
            * **没有使用文档！没有架构示意图！没有文章支撑！** 架构、组织形式等需要自己摸索；
            * 项目维护频率低，几乎一月一更或者一月两三更；~~有点在25年4月搞个大新闻就跑路的意思~~
        * 与其他多智能体框架的对比（参考自[这篇随送](https://mp.weixin.qq.com/s/au01PvkxIisddBih36bqzA)）
            * 与`AutoGPT`相比，`AutoGPT`更像是实验性质的初步尝试，“仅支持单Agent，靠prompt驱动一切，易发散、难维护”，而`OpenManus`更像是工程实用导向的框架；
            * 与`LangChain`相比，`LangChain`侧重于提供多种工具支持，而`OpenManus`是“尝试构建完整执行闭环”（理解为类似`LangGraph`的流程编排）；
            * 与`CrewAI` / `MetaGPT`相比，前两者“更适合写作、分析、协作型任务”，`OpenManus`“关注任务是否真正被完成”。
    * `OpenManus`的架构（参考自[这篇随送](https://mp.weixin.qq.com/s/k0h8ynyQAELq35m7gm-xAw)与[这篇回答](https://www.zhihu.com/question/14322364598/answer/120275203788)）  
        * 整体架构：
            ![](https://raw.githubusercontent.com/YouCaiJun98/MyPicBed/main/imgs/20260121145934.png)
        * 由三个基本模块构成：
            * [`Agent`](https://github.com/FoundationAgents/OpenManus/tree/main/app/agent)：继承自 BaseAgent 并可以执行任务的类；  
            * [`Tools`](https://github.com/FoundationAgents/OpenManus/tree/main/app/tool)：可用于完成任务的工具功能；  
            * [`LLM Integration`](https://github.com/FoundationAgents/OpenManus/blob/main/app/llm.py)：和LLM的通信层，兼容多种LLM格式/服务提供商（openai/claude/ollama/jiekouai...）  
        * `Agent`系统：
              ![](https://raw.githubusercontent.com/YouCaiJun98/MyPicBed/main/imgs/a318ebfeca22ce2b6a2311ff549ac3e1.png)
        * 由以下`Agent`构成：
            * [`BaseAgent`](https://github.com/FoundationAgents/OpenManus/blob/main/app/agent/base.py)：所有Agent的基类，负责管理状态和记忆。
            * [`ReActAgent`](https://github.com/FoundationAgents/OpenManus/blob/main/app/agent/react.py)：实现推理和行动的循环。
            * [`ToolCallAgent`](https://github.com/FoundationAgents/OpenManus/blob/main/app/agent/toolcall.py)：处理工具调用，根据LLM决策执行工具。
            * [`Manus`](https://github.com/FoundationAgents/OpenManus/blob/main/app/agent/manus.py)：多功能通用Agent，标准模式下使用的主代理。
            * [`BrowserAgent`](https://github.com/FoundationAgents/OpenManus/blob/main/app/agent/browser.py)：专门用于浏览器交互的Agent。
        * `OpenManus`的工作流程：
            ![](https://raw.githubusercontent.com/YouCaiJun98/MyPicBed/main/imgs/20260121150055.png)  
            1. Agent向LLM询问进行思考（决定做什么）；  
            2. LLM建议工具调用执行；  
            3. Agent执行工具并观察结果；  
            4. 循环重复，直到任务完成或达到最大步数；  
    * 需要解决以下问题才能使用`OpenManus`:
        * 修改`requirements.txt`中的`crawl4ai`版本避免依赖冲突，`crawl4ai~=0.7.2`；
        * 手动`pip`安装`daytona`、`structlog`等`requirements.txt`中缺失的依赖；
        * 在官方示例`./config/config.toml`文件末尾添加以下字段：
            ```
            [daytona]
            daytona_api_key = "your_api_key"
            daytona_server_url = "https://app.daytona.io/api"
            daytona_target = "cn"
            ```
    * 尝试若干LLM serve方法：
        ❌ `OpenAI - API`模式，需要本地代理+账号token余额，尝试更换国内二手服务商，发现接口不通畅；
        ✔️ `ollama`本地serve方法，在本地端口启动`llama3.2`服务，利用`OpenManus`访问；
    * 尝试使用`OpenManus`运行官方给的[样例](https://github.com/FoundationAgents/OpenManus/tree/main/examples/use_case):  
        * 使用`ollama`在本地serve模型，发现：
            * 尝试`Gemma3:12b`模型,发现`Gemma3`系列不支持工具调用，无法与`OpenManus`搭配使用；
            * `llama3.2`模型在使用中发现两个问题：①`llama3.2`优先访问英文页面（模型直接输出的url就是外网连接），且幻觉严重（生成了很多不存在的url，而且是根据记忆直接去某些特定的页面，而不是打开google等搜索引擎），无法从网络页面获取有效信息；②在模型的think阶段，生成的LLM response会产生大量重复回答（同一个工具调用命令，重复40次，区别仅在于id不同，而id应该是LLM服务框架自动生成的），检查`OpenManus`传递的信息，未发现异常（输入内容正常，且未发现重复调用现象），问题可能出在`ollama`框架或`llama3.2`模型本身，因涉及跨框架联调，暂时未深入研究。**未完成一次示例**。
            * `ollama`的官方hub中给出的例子比`Gemma3`更老 / 规模太大，没有试其他的模型；  
            * 
        * 使用`Deepseek API`（`DeepseekV3.2-chat`），发现`OpenManus`的成功率很有限，表现为：
            * LLM对页面的控制很不稳定，经常出现文字输入失败等问题，无法正常使用网络页面搜索功能（这或许是LLM本身能力的问题）；具体而言，LLM可以和网页有限交互，比如可以点击某些按钮跳转页面，但是需要在输入框输入某些文字进行查询的时候经常出错；
            * 国内的互联网生态很烂（壁垒很高，封闭性太强），在查询的时候经常要登录验证，导致LLM陷入死循环，或许在外网`OpenManus`的联网搜索表现会更好；
            * 在浏览器搜索失败以后，LLM通常会根据自己的资料库生成文件：
            ![](https://raw.githubusercontent.com/YouCaiJun98/MyPicBed/main/imgs/68a207fa0e6660541b91e811162bdcb.png)
            * `OpenManus`的本地文件创建与代码执行表现不错，可以正常在本地新建文件，并执行`Python`脚本。  